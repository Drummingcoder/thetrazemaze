<!DOCTYPE html>
<html>
<head>
  <title>The Traze Maze</title>
  <link rel="icon" type="icon/x-image" href="logo.jpg">
  <link rel="stylesheet" type="text/css" href="mazestyle.css">
  <style>
    body {
      text-align: center;
      background: linear-gradient(45deg, #1E3A8A 0%, #3B82F6 25%, #8B5CF6 50%, #F59E0B 75%, #FF8C00 100%);
      background-size: 400% 400%;
      animation: gradientShift 8s ease-in-out infinite;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Animated gradient background */
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    /* COMMENTED OUT - Two large waving stickmen on sides of maze - optimized for performance */
    /*
    .waving-stickman {
      position: fixed;
      width: 96px;
      height: 96px;
      background-image: url('waving-stickman-spritesheet.png');
      background-size: 288px 96px;
      background-repeat: no-repeat;
      background-position: 0 0;
      pointer-events: none;
      z-index: -1;
      opacity: 0.9;
      image-rendering: pixelated;
      will-change: background-position;
    }
    
    .stickman-left { 
      top: 50%; 
      left: 5%; 
      transform: translateY(-50%);
      animation: waveFrames 2.0s steps(3) infinite; 
    }
    .stickman-right { 
      top: 50%; 
      right: 5%; 
      transform: translateY(-50%);
      animation: waveFrames 2.2s steps(3) infinite 0.5s;
    }
    
    @keyframes waveFrames {
      0% { background-position: 0 0; }
      33.33% { background-position: -96px 0; }
      66.66% { background-position: -192px 0; }
      100% { background-position: 0 0; }
    }
    */

    #timer {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(30, 58, 95, 0.95); /* Dark blue background to match theme */
      color: #FFFFFF; /* White text for contrast */
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      font-weight: bold;
      z-index: 1000;
      border: 2px solid #3B82F6; /* Lighter blue border */
      box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
    }

    #maze-container {
      position: relative;
      overflow: hidden;
      /* Dynamic sizing will be applied via JavaScript */
    }

    #maze-canvas {
      display: block;
      image-rendering: pixelated; /* Keep crisp edges */
      /* Dynamic sizing and positioning will be applied via JavaScript */
    }
    
    /* Preload critical images */
    body::after {
      content: '';
      position: absolute;
      left: -9999px;
      background-image: url('stickman-running-spritesheet.png'), url('waving-stickman-spritesheet.png');
    }
  </style>
</head>
<body>
  <!-- COMMENTED OUT - Two large waving stickmen on either side of the maze -->
  <!-- <div class="waving-stickman stickman-left"></div> -->
  <!-- <div class="waving-stickman stickman-right"></div> -->
  
  <div id="timer">00:00.000</div>
  <div id="maze-container">
    <canvas id="maze-canvas"></canvas>
  </div>

  <div id="end-screen" class="hidden">
  <button id="back-button">Back</button>
  <h2>Congratulations!</h2>

  <div id="end-time-taken"></div>
  <div id="personal-best">
    Personal Best: <span id="best-time"></span>
  </div>
  <div id="new-personal-best" style = "display:block;">Personal New Best!</div>

    <button id="copy-button">Copy Maze and Time</button>
    <button id="restart-button">Restart Maze</button>
  </div>
  
  <script src="./newlibrary.js"></script>

  <script>
    // FORCE CLEAR all browser storage to prevent any data persistence between sessions
    try {
      sessionStorage.clear();
      // Don't clear localStorage as it contains best times
    } catch (e) {
      // Silently handle storage errors
    }
    
    // Lazy audio loading system - loads audio after maze initialization
    let audioPreloaded = false;
    let musicStarted = false;
    let audioLoadingInProgress = false;

    function preloadAudioAsync() {
      if (audioPreloaded || audioLoadingInProgress) return;
      
      audioLoadingInProgress = true;
      console.log('Starting lazy audio preload...');
      
      // Use setTimeout to prevent blocking the main thread
      setTimeout(() => {
        try {
          myLibrary.preloadAudio();
          audioPreloaded = true;
          audioLoadingInProgress = false;
          console.log('Audio preloaded successfully');
        } catch (error) {
          console.warn('Audio preload failed:', error);
          audioPreloaded = false;
          audioLoadingInProgress = false;
        }
      }, 150); // Small delay to ensure maze is fully rendered first
    }

    // Preload assets immediately when script loads
    window.addEventListener('DOMContentLoaded', function() {
      // Only preload images immediately - audio will be loaded later
      const preloadImages = ['stickman-running-spritesheet.png', 'waving-stickman-spritesheet.png'];
      preloadImages.forEach(src => {
        const img = new Image();
        img.src = src;
        img.style.display = 'none';
        document.body.appendChild(img);
      });
    });
 
  var searchParams = new URLSearchParams(window.location.search);
  var type = searchParams.get('type');
  var multiple = searchParams.get('multiple');
  var difficulty = searchParams.get('difficulty') || 'medium'; // Default to medium if not specified
  var mode = searchParams.get('mode') || 'hard'; // Default to hard mode if not specified
  
  // Complex navigable maze with 4x4 path areas and 2x2 walls - designed for challenge and fun (1 = wall, 0 = path)
  const predefinedMaze = [
     [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  
  // Set maze size based on predefined maze
  mazeSize = predefinedMaze.length;
  
  // Calculate the maximum possible cell size to fill the screen
  const availableWidth = window.innerWidth;
  const availableHeight = window.innerHeight;
  
  // Calculate cell size based on screen dimensions and maze size
  const maxCellSizeWidth = Math.floor(availableWidth / mazeSize);
  const maxCellSizeHeight = Math.floor(availableHeight / mazeSize);
  
  // Use the smaller of the two to ensure the maze fits in both dimensions
  cellSize = Math.min(maxCellSizeWidth, maxCellSizeHeight);
  
  // Ensure minimum cell size for playability (but don't limit maximum)
  if (cellSize < 3) {
    cellSize = 3; // Minimum viable cell size
  }
  
  // Calculate actual maze dimensions in pixels
  const mazeWidthPx = mazeSize * cellSize;
  const mazeHeightPx = mazeSize * cellSize;
  
  // Set easy flag based on mode
  var easy = (mode === 'easy'); // Make global for library.js
  
  // Apply dynamic styling
  const mazeContainer = document.getElementById("maze-container");
  const canvas = document.getElementById("maze-canvas");
  const ctx = canvas.getContext("2d");
  
  // Set canvas size to the actual maze size
  canvas.width = mazeWidthPx;
  canvas.height = mazeHeightPx;
  
  // Make the container fill the screen and center the maze
  const style = document.createElement('style');
  style.textContent = `
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      min-height: 100vh;
      min-width: 100vw;
    }
    #maze-container {
      width: ${mazeWidthPx}px;
      height: ${mazeHeightPx}px;
      position: absolute;
      top: 0;
      left: 0;
      overflow: visible;
    }
    #maze-canvas {
      display: block;
      image-rendering: pixelated;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
  `;
  document.head.appendChild(style);

    var maze = document.getElementById("maze-container"); // Make global for library.js
    const timerElement = document.getElementById("timer");
    const endScreen = document.getElementById("end-screen");
    const restartButton = document.getElementById("restart-button");
    const backButton = document.getElementById("back-button");
    const endContent = document.getElementById("end-time-taken");
    const personalbest = document.getElementById("personal-best");
    const newpersonalbest = document.getElementById("new-personal-best");

    var mazeStructure, startRow, startCol, endRow, endCol; // Make global for library.js
    let time = 0;
    let interval = false, startMaze;
    let first = 0;
    var mazecount = 0; // Make global for library.js
    
    // Canvas rendering system - smooth pixel-based movement system
    // FORCE RESET to 0 to prevent any persistence across reloads
    let playerX = 0, playerY = 0; // Player position in pixels - EXPLICITLY RESET TO 0
    
    // Smooth movement system variables
    let playerIsMoving = false;
    let movementSpeed = 6; // Increased from 3 to 6 pixels per frame for faster movement
    let smoothMovementKeys = {};
    let animationFrameId = null;
    
    // Collision detection for smooth movement
    function checkCollision(newX, newY) {
      // Calculate which cells the player would occupy
      const spriteSize = cellSize * 0.8;
      const centerOffset = (cellSize - spriteSize) / 2;
      
      // Check all four corners of the player sprite plus center
      const checkPoints = [
        { x: newX + centerOffset + 2, y: newY + centerOffset + 2 }, // Top-left (with small margin)
        { x: newX + centerOffset + spriteSize - 3, y: newY + centerOffset + 2 }, // Top-right
        { x: newX + centerOffset + 2, y: newY + centerOffset + spriteSize - 3 }, // Bottom-left
        { x: newX + centerOffset + spriteSize - 3, y: newY + centerOffset + spriteSize - 3 }, // Bottom-right
        { x: newX + centerOffset + spriteSize/2, y: newY + centerOffset + spriteSize/2 } // Center
      ];
      
      // Check if any point is in a wall
      for (const point of checkPoints) {
        const col = Math.floor(point.x / cellSize);
        const row = Math.floor(point.y / cellSize);
        
        // Check bounds
        if (row < 0 || row >= mazeSize || col < 0 || col >= mazeSize) {
          return true; // Collision with maze boundary
        }
        
        // Check if this cell is a wall
        if (mazeStructure[row] && mazeStructure[row][col] === 1) {
          return true; // Collision with wall
        }
      }
      
      return false; // No collision
    }
    
    // Check if player reached the end
    function checkEndReached() {
      const spriteSize = cellSize * 0.8;
      const centerOffset = (cellSize - spriteSize) / 2;
      const playerCenterX = playerX + centerOffset + spriteSize / 2;
      const playerCenterY = playerY + centerOffset + spriteSize / 2;
      
      const playerCol = Math.floor(playerCenterX / cellSize);
      const playerRow = Math.floor(playerCenterY / cellSize);
      
      return (playerRow === endRow && playerCol === endCol);
    }
    
    // Smooth movement animation loop
    function smoothMovementLoop() {
      let moved = false;
      let newX = playerX;
      let newY = playerY;
      
      // Calculate movement based on pressed keys
      if (smoothMovementKeys["ArrowUp"] || smoothMovementKeys["w"]) {
        newY -= movementSpeed;
        moved = true;
      }
      if (smoothMovementKeys["ArrowDown"] || smoothMovementKeys["s"]) {
        newY += movementSpeed;
        moved = true;
      }
      if (smoothMovementKeys["ArrowLeft"] || smoothMovementKeys["a"]) {
        newX -= movementSpeed;
        moved = true;
      }
      if (smoothMovementKeys["ArrowRight"] || smoothMovementKeys["d"]) {
        newX += movementSpeed;
        moved = true;
      }
      
      // Apply movement if no collision - check each axis separately for wall sliding
      if (moved) {
        let finalX = playerX;
        let finalY = playerY;
        
        // Try horizontal movement first
        if (newX !== playerX && !checkCollision(newX, playerY)) {
          finalX = newX;
        }
        
        // Try vertical movement
        if (newY !== playerY && !checkCollision(finalX, newY)) {
          finalY = newY;
        }
        
        // Update player position if it changed
        if (finalX !== playerX || finalY !== playerY) {
          playerX = finalX;
          playerY = finalY;
          
          // Update virtual player object for library compatibility
          player.style.left = playerX + "px";
          player.style.top = playerY + "px";
          
          // Check if player reached the end
          if (checkEndReached()) {
            // Clean up all movement and animation systems
            cleanupGameSystems();
            
            // Trigger end game
            setTimeout(() => {
              myLibrary.endGame(endScreen, startTime, endContent, type, personalbest, newpersonalbest, interval);
            }, 100);
          }
          
          // Update camera and render (throttled to reduce excessive redraws)
          updateCameraAndRender();
        }
      }
      
      // Continue animation loop if any keys are pressed
      const anyKeyPressed = Object.values(smoothMovementKeys).some(pressed => pressed);
      if (anyKeyPressed) {
        animationFrameId = requestAnimationFrame(smoothMovementLoop);
      } else {
        animationFrameId = null;
        playerIsMoving = false;
      }
    }
    
    // Comprehensive cleanup function to prevent memory leaks and accumulation
    function cleanupGameSystems() {
      // Stop smooth movement
      smoothMovementKeys = {};
      keysPressed = {};
      playerIsMoving = false;
      
      // Cancel any pending animation frames
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear any audio check intervals
      if (audioCheckInterval) {
        clearInterval(audioCheckInterval);
        audioCheckInterval = null;
      }
      
      // Reset render state
      renderPending = false;
      renderQueued = false;
      cameraUpdatePending = false;
      
      // Reset timer variables
      lastRenderTime = 0;
      
      console.log('Game systems cleaned up');
    }
    
    // NEW SIMPLIFIED CAMERA SYSTEM - COMPLETE REPLACEMENT
    let cameraX = 0;
    let cameraY = 0;
    let currentZoom = 1.0;
    let cameraEnabled = false;
    
    // Optimized canvas rendering system with better throttling
    let renderPending = false;
    let lastRenderTime = 0;
    const RENDER_THROTTLE = 8; // 120 FPS max for smoother movement
    let renderQueued = false;
    
    function drawMaze() {
      // Always redraw the entire maze - this is actually faster and simpler
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set maze colors
      const wallColor = '#000000';      // Black walls
      const pathColor = '#87CEEB';      // Light blue paths
      const startColor = '#00FF00';     // Green start
      const endColor = '#FF0000';       // Red end
      
      // Collect cells by color for batched drawing
      const walls = [];
      const paths = [];
      let startCell = null;
      let endCell = null;
      
      // First pass: categorize all cells
      for (let row = 0; row < mazeSize; row++) {
        for (let col = 0; col < mazeSize; col++) {
          const x = col * cellSize;
          const y = row * cellSize;
          
          if (mazeStructure && mazeStructure[row] && mazeStructure[row][col] === 0) {
            if (row === startRow && col === startCol) {
              startCell = [x, y];
            } else if (row === endRow && col === endCol) {
              endCell = [x, y];
            } else {
              paths.push([x, y]);
            }
          } else {
            walls.push([x, y]);
          }
        }
      }
      
      // Second pass: draw all cells of same color together
      // Draw walls
      if (walls.length > 0) {
        ctx.fillStyle = wallColor;
        ctx.beginPath();
        for (const [x, y] of walls) {
          ctx.rect(x, y, cellSize, cellSize);
        }
        ctx.fill();
      }
      
      // Draw paths
      if (paths.length > 0) {
        ctx.fillStyle = pathColor;
        ctx.beginPath();
        for (const [x, y] of paths) {
          ctx.rect(x, y, cellSize, cellSize);
        }
        ctx.fill();
      }
      
      // Draw start cell
      if (startCell) {
        ctx.fillStyle = startColor;
        ctx.fillRect(startCell[0], startCell[1], cellSize, cellSize);
      }
      
      // Draw end cell
      if (endCell) {
        ctx.fillStyle = endColor;
        ctx.fillRect(endCell[0], endCell[1], cellSize, cellSize);
      }
    }
    
    function drawPlayer() {
      // Simple player drawing - let the render throttling handle performance
      const spriteSize = cellSize * 0.8; // 80% of cell size to avoid wall clipping
      const centerOffset = (cellSize - spriteSize) / 2;
      const destX = playerX + centerOffset;
      const destY = playerY + centerOffset;
      
      // Ensure player is visible by using high contrast colors
      ctx.fillStyle = '#0066FF'; // Blue player square
      ctx.fillRect(destX, destY, spriteSize, spriteSize);
      
      // Add a white border around the player for better visibility
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = Math.max(1, cellSize * 0.05); // Scale border with cell size
      ctx.strokeRect(destX, destY, spriteSize, spriteSize);
    }
    
    // Performance monitoring to detect issues early
    let frameCount = 0;
    let lastPerformanceCheck = performance.now();
    
    function monitorPerformance() {
      frameCount++;
      const now = performance.now();
      
      // Check performance every 5 seconds
      if (now - lastPerformanceCheck > 5000) {
        const fps = frameCount / ((now - lastPerformanceCheck) / 1000);
        if (fps < 30) {
          console.warn(`Low FPS detected: ${fps.toFixed(1)} FPS`);
        }
        frameCount = 0;
        lastPerformanceCheck = now;
      }
    }

    function renderFrame() {
      // Prevent multiple pending renders
      if (renderPending) return;
      
      const now = performance.now();
      if (now - lastRenderTime < RENDER_THROTTLE) {
        // Use requestAnimationFrame instead of setTimeout to avoid accumulation
        if (!renderQueued) {
          renderQueued = true;
          requestAnimationFrame(() => {
            renderQueued = false;
            if (performance.now() - lastRenderTime >= RENDER_THROTTLE) {
              renderFrame();
            }
          });
        }
        return;
      }
      
      renderPending = true;
      lastRenderTime = now;
      
      requestAnimationFrame(() => {
        try {
          // Simple approach: always redraw everything 
          drawMaze();
          drawPlayer();
          
          // Monitor performance
          monitorPerformance();
        } catch (error) {
          console.error('Error in renderFrame:', error);
        } finally {
          renderPending = false;
        }
      });
    }
    
    function updatePlayerPosition(newRow, newCol) {
      // For smooth movement, this function is simplified
      // Position updates happen directly in smoothMovementLoop()
      if (newRow !== undefined && newCol !== undefined) {
        playerX = newCol * cellSize;
        playerY = newRow * cellSize;
        updateCameraAndRender();
      }
    }
    
    // Movement state tracking - simplified for smooth movement
    let keysPressed = {};
    
    // Pre-warm animation system to reduce first-run lag
    function prepareAnimationSystem() {
      // Create a test animation cycle to warm up the browser's animation engine
      renderFrame();
    }
    
    // NEW SIMPLIFIED CAMERA SYSTEM - COMPLETE REPLACEMENT
    let cameraUpdatePending = false;
    
    function initializeNewCamera() {
      // Calculate optimal zoom level
      const viewportW = window.innerWidth;
      const viewportH = window.innerHeight;
      const smallerDimension = Math.min(viewportW, viewportH);
      
      // Show about 12-15 cells in the smaller screen dimension
      const targetCellsVisible = 12;
      currentZoom = Math.max(1.5, Math.min(4.0, smallerDimension / (targetCellsVisible * cellSize)));
      
      // Center camera on player immediately
      centerOnPlayer();
      
      // Enable camera following
      cameraEnabled = true;
    }

    function centerOnPlayer() {
      // Get player's center position in world coordinates
      const playerCenterX = playerX + (cellSize / 2);
      const playerCenterY = playerY + (cellSize / 2);
      
      // Calculate where to position the canvas so player appears at screen center
      const screenCenterX = window.innerWidth / 2;
      const screenCenterY = window.innerHeight / 2;
      
      // Simple formula: translate = (screenCenter / zoom) - playerCenter
      cameraX = (screenCenterX / currentZoom) - playerCenterX;
      cameraY = (screenCenterY / currentZoom) - playerCenterY;
      
      // Apply the transform immediately
      applyCamera();
    }

    function applyCamera() {
      // Batch transform application - single transform string
      const transform = `scale(${currentZoom}) translate(${cameraX}px, ${cameraY}px)`;
      canvas.style.transform = transform;
      canvas.style.transformOrigin = '0 0';
    }

    function updateCamera() {
      if (!cameraEnabled || cameraUpdatePending) return;
      
      cameraUpdatePending = true;
      requestAnimationFrame(() => {
        centerOnPlayer(); // This already calls applyCamera()
        cameraUpdatePending = false;
      });
    }
    
    // Batched update function - combines camera and render
    function updateCameraAndRender() {
      if (cameraEnabled) {
        updateCamera();
      }
      renderFrame();
    }

    // Replace the old camera functions
    function zoomInOnPlayer() {
      initializeNewCamera();
    }

    function centerCameraOnPlayer() {
      centerOnPlayer();
    }

    function updateCameraPosition() {
      updateCamera();
    }

    function resetCamera() {
      cameraEnabled = false;
      currentZoom = 1.0;
      cameraX = 0;
      cameraY = 0;
      // Force reset the canvas transform
      canvas.style.transform = 'scale(1) translate(0px, 0px)';
      canvas.style.transformOrigin = '0 0';
      // Clear any existing transforms
      canvas.style.webkitTransform = 'scale(1) translate(0px, 0px)';
    }

    // Remove all the old camera animation complexity
    function startCameraAnimation() {
      // No animation needed - camera updates instantly
      updateCamera();
    }

    // Setup predefined maze
    mazeStructure = predefinedMaze;
    
    // Set start and end positions for the predefined maze
    startRow = 2;  // In the expanded wide path area (top-left)
    startCol = 2;
    endRow = 46;   // Bottom right corner (last row - 1)
    endCol = 46;   // Bottom right corner (last column - 1)
    
    // CRITICAL: Prevent any changes to start position
    Object.defineProperty(window, 'startRow', {
      value: 2,
      writable: false,
      configurable: false
    });
    Object.defineProperty(window, 'startCol', {
      value: 2,
      writable: false,
      configurable: false
    });
    
    // IMMEDIATE FORCE RESET player position to starting position (BEFORE ANY OTHER CODE)
    // EXPLICIT reset with logging
    playerX = startCol * cellSize;
    playerY = startRow * cellSize;
    
    // Don't call createMaze since we're using our own Canvas rendering
    // myLibrary.createMaze();

    // Create a virtual player object that mimics DOM behavior for library compatibility
    var player = {
      style: {
        get top() { 
          return playerY + "px"; 
        },
        set top(value) { 
          const newY = parseInt(value);
          playerY = newY;
          // Don't trigger camera/render immediately - let movement system batch updates
        },
        get left() { 
          return playerX + "px"; 
        },
        set left(value) { 
          const newX = parseInt(value);
          playerX = newX;
          // Don't trigger camera/render immediately - let movement system batch updates
        }
      }
    };
    
    // Initialize the canvas rendering system
    function initializeGame() {
      // FORCE RESET all state variables
      playerIsMoving = false;
      
      // FORCE RESET player position to starting position
      playerX = startCol * cellSize;
      playerY = startRow * cellSize;
      
      // Force a complete camera reset first
      resetCamera();
      
      // Force initial render to ensure maze is visible
      renderFrame();
      prepareAnimationSystem();
      
      // Initialize new camera system after reset
      setTimeout(() => {
        initializeNewCamera();
        // Force another render to ensure everything is visible
        renderFrame();
        
        // Start lazy audio loading AFTER maze is fully initialized
        setTimeout(() => {
          preloadAudioAsync();
        }, 100); // Additional delay to ensure smooth maze startup
      }, 50); // Small delay to ensure reset is complete
    }
    
    // Force complete reset on page load
    window.addEventListener('load', function() {
      resetCamera();
      initializeGame();
      
      // Start audio loading after page is fully loaded and maze is initialized
      setTimeout(() => {
        if (!audioPreloaded && !audioLoadingInProgress) {
          preloadAudioAsync();
        }
      }, 200); // Ensure maze has time to fully initialize
    });
    
    // No need to wait for sprite loading - initialize immediately
    initializeGame();

  // Smooth pixel-based movement system - replaces cell-based movement
  window.addEventListener("keydown", (event) => {
    if (event.key === "y" || event.key === "Y") {
      // Calculate player's grid position for debugging
      const playerGridRow = Math.round(playerY / cellSize);
      const playerGridCol = Math.round(playerX / cellSize);
      const mazeCenter = Math.round(mazeSize / 2);
      const distanceFromCenter = Math.sqrt(Math.pow(playerGridRow - mazeCenter, 2) + Math.pow(playerGridCol - mazeCenter, 2));
      
      console.log(`Player Position: Row ${playerGridRow}, Col ${playerGridCol} (Pixel: ${playerX}, ${playerY}) (distance from center: ${distanceFromCenter.toFixed(2)})`);
      return;
    }
    
    // Audio interval tracking to prevent leaks
    let audioCheckInterval = null;
    
    if (event.key.includes("Arrow") || event.key === "w" || event.key === "a" || event.key === "s" || event.key === "d") {
      event.preventDefault();
      
      // Start timer and music only once
      if (!interval) {
        interval = true;
        const { startTime: capturedStartTime, interval: capturedInterval } = myLibrary.startTimer(timerElement);
        startTime = capturedStartTime;
      }
      if (first === 0) {
        // Smart music playback - play immediately if loaded, queue if still loading
        if (audioPreloaded && !musicStarted) {
          // Audio ready - start music immediately
          setTimeout(() => {
            try {
              myLibrary.playMusic();
              musicStarted = true;
              console.log('Music started successfully');
            } catch (error) {
              console.warn('Music playback failed:', error);
            }
          }, 0);
        } else if (!musicStarted && !audioCheckInterval) {
          // Audio not ready - set up a check to start music when available
          console.log('Audio still loading, will start music when ready...');
          audioCheckInterval = setInterval(() => {
            if (audioPreloaded && !musicStarted) {
              try {
                myLibrary.playMusic();
                musicStarted = true;
                console.log('Music started after audio loading completed');
                clearInterval(audioCheckInterval);
                audioCheckInterval = null;
              } catch (error) {
                console.warn('Music playback failed:', error);
                clearInterval(audioCheckInterval);
                audioCheckInterval = null;
              }
            }
          }, 100);
          
          // Safety timeout to prevent infinite checking (stop trying after 10 seconds)
          setTimeout(() => {
            if (!musicStarted && audioCheckInterval) {
              console.warn('Audio loading timeout - continuing without music');
              clearInterval(audioCheckInterval);
              audioCheckInterval = null;
            }
          }, 10000);
        }
        first++;
      }
      
      // Mark player as moving
      playerIsMoving = true;
      
      // Add key to smooth movement keys
      smoothMovementKeys[event.key] = true;
      
      // Start smooth movement loop if not already running
      if (!animationFrameId) {
        animationFrameId = requestAnimationFrame(smoothMovementLoop);
      }
    }
  });

  window.addEventListener("keyup", (event) => {
    if (event.key.includes("Arrow") || event.key === "w" || event.key === "a" || event.key === "s" || event.key === "d") {
      // Remove key from smooth movement keys
      smoothMovementKeys[event.key] = false;
      
      // Check if any movement keys are still pressed
      const anyKeyPressed = Object.values(smoothMovementKeys).some(pressed => pressed);
      
      // Stop movement if no keys are pressed
      if (!anyKeyPressed) {
        playerIsMoving = false;
        // Animation loop will stop itself when no keys are pressed
      }
    }
  });

  // Remove old cell-based movement function - replaced with smooth movement
  // function startContinuousMovement() { ... } - REMOVED
    
    // Prevent duplicate event listeners
    if (!restartButton.hasAttribute('data-initialized')) {
      restartButton.addEventListener("click", function() {
        cleanupGameSystems();
        resetCamera();
        myLibrary.restartMaze();
      });
      restartButton.setAttribute('data-initialized', 'true');
    }
    
    if (!backButton.hasAttribute('data-initialized')) {
      backButton.addEventListener("click", myLibrary.goBack);
      backButton.style.display = "inline-block";
      backButton.addEventListener("click", myLibrary.hideEndScreen);
      backButton.setAttribute('data-initialized', 'true');
    }
    
    // Set the appropriate copy function based on mode (prevent duplicates)
    const copyButton = document.getElementById("copy-button");
    if (copyButton && !copyButton.hasAttribute('data-initialized')) {
      if (easy) {
        copyButton.addEventListener("click", myLibrary.copyEasyMazeAndTime);
      } else {
        copyButton.addEventListener("click", myLibrary.copyMazeAndTime);
      }
      copyButton.setAttribute('data-initialized', 'true');
    }
    
    // Handle window resize to recalculate maze size
    function resizeMaze() {
      // Recalculate the maximum possible cell size to fill the screen
      const availableWidth = window.innerWidth;
      const availableHeight = window.innerHeight;
      
      // Calculate cell size based on screen dimensions and maze size
      const maxCellSizeWidth = Math.floor(availableWidth / mazeSize);
      const maxCellSizeHeight = Math.floor(availableHeight / mazeSize);
      
      // Use the smaller of the two to ensure the maze fits in both dimensions
      cellSize = Math.min(maxCellSizeWidth, maxCellSizeHeight);
      
      // Ensure minimum cell size for playability
      if (cellSize < 3) {
        cellSize = 3;
      }
      
      // Calculate actual maze dimensions in pixels
      const mazeWidthPx = mazeSize * cellSize;
      const mazeHeightPx = mazeSize * cellSize;
      
      // Update canvas size
      canvas.width = mazeWidthPx;
      canvas.height = mazeHeightPx;
      
      // Update container size
      mazeContainer.style.width = mazeWidthPx + 'px';
      mazeContainer.style.height = mazeHeightPx + 'px';
      
      // Update player position to match new cell size
      const currentCol = Math.round(playerX / (canvas.width / mazeSize));
      const currentRow = Math.round(playerY / (canvas.height / mazeSize));
      playerX = currentCol * cellSize;
      playerY = currentRow * cellSize;
      
      // Re-calculate zoom and camera position for new dimensions
      if (cameraEnabled) {
        // Recalculate zoom scale for new screen size
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const smallerDimension = Math.min(viewportWidth, viewportHeight);
        const targetCellsVisible = 12;
        currentZoom = Math.max(1.5, Math.min(4.0, smallerDimension / (targetCellsVisible * cellSize)));
        
        // Re-center camera on player
        centerOnPlayer();
      }
      
      // Re-render the maze
      renderFrame();
    }
    
    // Add resize event listener with debouncing (prevent duplicates)
    let resizeTimeout;
    if (!window.hasAttribute || !window.hasAttribute('data-resize-initialized')) {
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(resizeMaze, 100);
      });
      // Mark as initialized (use a global flag since window doesn't support setAttribute)
      window.resizeHandlerInitialized = true;
    }
  </script>
</body>
</html>
