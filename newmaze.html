<!DOCTYPE html>
<html>
<head>
  <title>The Traze Maze</title>
  <link rel="icon" type="icon/x-image" href="logo.jpg">
  <link rel="stylesheet" type="text/css" href="mazestyle.css">
  <style>
    body {
      text-align: center;
      background: linear-gradient(45deg, #1E3A8A 0%, #3B82F6 25%, #8B5CF6 50%, #F59E0B 75%, #FF8C00 100%);
      background-size: 400% 400%;
      animation: gradientShift 8s ease-in-out infinite;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Animated gradient background */
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    /* COMMENTED OUT - Two large waving stickmen on sides of maze - optimized for performance */
    /*
    .waving-stickman {
      position: fixed;
      width: 96px;
      height: 96px;
      background-image: url('waving-stickman-spritesheet.png');
      background-size: 288px 96px;
      background-repeat: no-repeat;
      background-position: 0 0;
      pointer-events: none;
      z-index: -1;
      opacity: 0.9;
      image-rendering: pixelated;
      will-change: background-position;
    }
    
    .stickman-left { 
      top: 50%; 
      left: 5%; 
      transform: translateY(-50%);
      animation: waveFrames 2.0s steps(3) infinite; 
    }
    .stickman-right { 
      top: 50%; 
      right: 5%; 
      transform: translateY(-50%);
      animation: waveFrames 2.2s steps(3) infinite 0.5s;
    }
    
    @keyframes waveFrames {
      0% { background-position: 0 0; }
      33.33% { background-position: -96px 0; }
      66.66% { background-position: -192px 0; }
      100% { background-position: 0 0; }
    }
    */

    #timer {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(30, 58, 95, 0.95); /* Dark blue background to match theme */
      color: #FFFFFF; /* White text for contrast */
      padding: 10px 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      font-weight: bold;
      z-index: 1000;
      border: 2px solid #3B82F6; /* Lighter blue border */
      box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
    }

    #maze-container {
      position: relative;
      overflow: hidden;
      /* Dynamic sizing will be applied via JavaScript */
    }

    #maze-canvas {
      display: block;
      image-rendering: pixelated; /* Keep crisp edges */
      /* Dynamic sizing and positioning will be applied via JavaScript */
    }
    
    /* Preload critical images */
    body::after {
      content: '';
      position: absolute;
      left: -9999px;
      background-image: url('stickman-running-spritesheet.png'), url('waving-stickman-spritesheet.png');
    }
  </style>
</head>
<body>
  <!-- COMMENTED OUT - Two large waving stickmen on either side of the maze -->
  <!-- <div class="waving-stickman stickman-left"></div> -->
  <!-- <div class="waving-stickman stickman-right"></div> -->
  
  <div id="timer">00:00.000</div>
  <div id="maze-container">
    <canvas id="maze-canvas"></canvas>
  </div>

  <div id="end-screen" class="hidden">
  <button id="back-button">Back</button>
  <h2>Congratulations!</h2>

  <div id="end-time-taken"></div>
  <div id="personal-best">
    Personal Best: <span id="best-time"></span>
  </div>
  <div id="new-personal-best" style = "display:block;">Personal New Best!</div>

    <button id="copy-button">Copy Maze and Time</button>
    <button id="restart-button">Restart Maze</button>
  </div>
  
  <script src="./newlibrary.js"></script>

  <script>
    // FORCE CLEAR all browser storage to prevent any data persistence between sessions
    try {
      sessionStorage.clear();
      // Don't clear localStorage as it contains best times
    } catch (e) {
      // Silently handle storage errors
    }
    
    // Lazy audio loading system - loads audio after maze initialization
    let audioPreloaded = false;
    let musicStarted = false;
    let audioLoadingInProgress = false;

    function preloadAudioAsync() {
      if (audioPreloaded || audioLoadingInProgress) return;
      
      audioLoadingInProgress = true;
      console.log('Starting lazy audio preload...');
      
      // Use setTimeout to prevent blocking the main thread
      setTimeout(() => {
        try {
          myLibrary.preloadAudio();
          audioPreloaded = true;
          audioLoadingInProgress = false;
          console.log('Audio preloaded successfully');
        } catch (error) {
          console.warn('Audio preload failed:', error);
          audioPreloaded = false;
          audioLoadingInProgress = false;
        }
      }, 150); // Small delay to ensure maze is fully rendered first
    }

    // Preload assets immediately when script loads
    window.addEventListener('DOMContentLoaded', function() {
      // Only preload images immediately - audio will be loaded later
      const preloadImages = ['stickman-running-spritesheet.png', 'waving-stickman-spritesheet.png'];
      preloadImages.forEach(src => {
        const img = new Image();
        img.src = src;
        img.style.display = 'none';
        document.body.appendChild(img);
      });
    });
 
  var searchParams = new URLSearchParams(window.location.search);
  var type = searchParams.get('type');
  var multiple = searchParams.get('multiple');
  var difficulty = searchParams.get('difficulty') || 'medium'; // Default to medium if not specified
  var mode = searchParams.get('mode') || 'hard'; // Default to hard mode if not specified
  
  // Complex navigable maze with 4x4 path areas and 2x2 walls - designed for challenge and fun (1 = wall, 0 = path)
  const predefinedMaze = [
     [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  
  // Set maze size based on predefined maze
  mazeSize = predefinedMaze.length;
  
  // Calculate the maximum possible cell size to fill the screen
  const availableWidth = window.innerWidth;
  const availableHeight = window.innerHeight;
  
  // Calculate cell size based on screen dimensions and maze size
  const maxCellSizeWidth = Math.floor(availableWidth / mazeSize);
  const maxCellSizeHeight = Math.floor(availableHeight / mazeSize);
  
  // Use the smaller of the two to ensure the maze fits in both dimensions
  cellSize = Math.min(maxCellSizeWidth, maxCellSizeHeight);
  
  // Ensure minimum cell size for playability (but don't limit maximum)
  if (cellSize < 3) {
    cellSize = 3; // Minimum viable cell size
  }
  
  // Calculate actual maze dimensions in pixels
  const mazeWidthPx = mazeSize * cellSize;
  const mazeHeightPx = mazeSize * cellSize;
  
  // Set easy flag based on mode
  var easy = (mode === 'easy'); // Make global for library.js
  
  // Apply dynamic styling
  const mazeContainer = document.getElementById("maze-container");
  const canvas = document.getElementById("maze-canvas");
  const ctx = canvas.getContext("2d");
  
  // Set canvas size to the actual maze size
  canvas.width = mazeWidthPx;
  canvas.height = mazeHeightPx;
  
  // Make the container fill the screen and center the maze
  const style = document.createElement('style');
  style.textContent = `
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      min-height: 100vh;
      min-width: 100vw;
    }
    #maze-container {
      width: ${mazeWidthPx}px;
      height: ${mazeHeightPx}px;
      position: absolute;
      top: 0;
      left: 0;
      overflow: visible;
    }
    #maze-canvas {
      display: block;
      image-rendering: pixelated;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
  `;
  document.head.appendChild(style);

    var maze = document.getElementById("maze-container"); // Make global for library.js
    const timerElement = document.getElementById("timer");
    const endScreen = document.getElementById("end-screen");
    const restartButton = document.getElementById("restart-button");
    const backButton = document.getElementById("back-button");
    const endContent = document.getElementById("end-time-taken");
    const personalbest = document.getElementById("personal-best");
    const newpersonalbest = document.getElementById("new-personal-best");

    var mazeStructure, startRow, startCol, endRow, endCol; // Make global for library.js
    let time = 0;
    let interval = false, startMaze;
    let first = 0;
    var mazecount = 0; // Make global for library.js
    
    // Canvas rendering system - simplified with square player - EXPLICITLY DECLARE ALL VARIABLES
    // FORCE RESET to 0 to prevent any persistence across reloads
    let playerX = 0, playerY = 0; // Player position in pixels - EXPLICITLY RESET TO 0
    
    // NEW SIMPLIFIED CAMERA SYSTEM - COMPLETE REPLACEMENT
    let cameraX = 0;
    let cameraY = 0;
    let currentZoom = 1.0;
    let cameraEnabled = false;
    
    // Optimized canvas rendering system with better throttling
    let renderPending = false;
    let lastRenderTime = 0;
    const RENDER_THROTTLE = 16; // 60 FPS max
    let renderQueued = false;
    
    function drawMaze() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set maze colors
      const wallColor = '#000000';      // Black walls
      const pathColor = '#87CEEB';      // Light blue paths
      const startColor = '#00FF00';     // Green start
      const endColor = '#FF0000';       // Red end
      
      // Collect cells by color for batched drawing
      const walls = [];
      const paths = [];
      let startCell = null;
      let endCell = null;
      
      // First pass: categorize all cells
      for (let row = 0; row < mazeSize; row++) {
        for (let col = 0; col < mazeSize; col++) {
          const x = col * cellSize;
          const y = row * cellSize;
          
          if (mazeStructure && mazeStructure[row] && mazeStructure[row][col] === 0) {
            if (row === startRow && col === startCol) {
              startCell = [x, y];
            } else if (row === endRow && col === endCol) {
              endCell = [x, y];
            } else {
              paths.push([x, y]);
            }
          } else {
            walls.push([x, y]);
          }
        }
      }
      
      // Second pass: draw all cells of same color together
      // Draw walls
      if (walls.length > 0) {
        ctx.fillStyle = wallColor;
        ctx.beginPath();
        for (const [x, y] of walls) {
          ctx.rect(x, y, cellSize, cellSize);
        }
        ctx.fill();
      }
      
      // Draw paths
      if (paths.length > 0) {
        ctx.fillStyle = pathColor;
        ctx.beginPath();
        for (const [x, y] of paths) {
          ctx.rect(x, y, cellSize, cellSize);
        }
        ctx.fill();
      }
      
      // Draw start cell
      if (startCell) {
        ctx.fillStyle = startColor;
        ctx.fillRect(startCell[0], startCell[1], cellSize, cellSize);
      }
      
      // Draw end cell
      if (endCell) {
        ctx.fillStyle = endColor;
        ctx.fillRect(endCell[0], endCell[1], cellSize, cellSize);
      }
    }
    
    function drawPlayer() {
      // Simple square player instead of animated sprite
      const spriteSize = cellSize * 0.8; // 80% of cell size to avoid wall clipping
      
      // Center the square within the cell to avoid wall clipping
      const centerOffset = (cellSize - spriteSize) / 2;
      
      // Draw player at the exact pixel position (playerX, playerY)
      const destX = playerX + centerOffset;
      const destY = playerY + centerOffset;
      
      // Ensure player is visible by using high contrast colors
      ctx.fillStyle = '#0066FF'; // Blue player square
      ctx.fillRect(destX, destY, spriteSize, spriteSize);
      
      // Add a white border around the player for better visibility
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = Math.max(1, cellSize * 0.05); // Scale border with cell size
      ctx.strokeRect(destX, destY, spriteSize, spriteSize);
    }
    
    function renderFrame() {
      // Prevent multiple pending renders
      if (renderPending || renderQueued) return;
      
      const now = performance.now();
      if (now - lastRenderTime < RENDER_THROTTLE) {
        // Queue a render for later if we're throttling
        if (!renderQueued) {
          renderQueued = true;
          setTimeout(() => {
            renderQueued = false;
            renderFrame();
          }, RENDER_THROTTLE - (now - lastRenderTime));
        }
        return;
      }
      
      renderPending = true;
      lastRenderTime = now;
      
      requestAnimationFrame(() => {
        try {
          drawMaze();
          drawPlayer();
        } catch (error) {
          console.error('Error in renderFrame:', error);
        } finally {
          renderPending = false;
        }
      });
    }
    
    function updatePlayerPosition(newRow, newCol) {
      // If called with parameters, update to specific position
      if (newRow !== undefined && newCol !== undefined) {
        playerX = newCol * cellSize;
        playerY = newRow * cellSize;
      }
      // Otherwise, sync with current player object position
      else {
        const currentX = parseInt(player.style.left);
        const currentY = parseInt(player.style.top);
        
        // Only update if significantly different
        const threshold = cellSize * 0.1;
        if (Math.abs(playerX - currentX) > threshold) {
          playerX = currentX;
        }
        if (Math.abs(playerY - currentY) > threshold) {
          playerY = currentY;
        }
      }
      
      // Batch camera and render updates - only call once
      updateCameraAndRender();
    }
    
    // Movement state tracking
    let keysPressed = {};
    let movementInterval;
    let currentDirection = null;
    
    // Pre-warm animation system to reduce first-run lag
    function prepareAnimationSystem() {
      // Create a test animation cycle to warm up the browser's animation engine
      renderFrame();
    }
    
    // NEW SIMPLIFIED CAMERA SYSTEM - COMPLETE REPLACEMENT
    let cameraUpdatePending = false;
    
    function initializeNewCamera() {
      // Calculate optimal zoom level
      const viewportW = window.innerWidth;
      const viewportH = window.innerHeight;
      const smallerDimension = Math.min(viewportW, viewportH);
      
      // Show about 12-15 cells in the smaller screen dimension
      const targetCellsVisible = 12;
      currentZoom = Math.max(1.5, Math.min(4.0, smallerDimension / (targetCellsVisible * cellSize)));
      
      // Center camera on player immediately
      centerOnPlayer();
      
      // Enable camera following
      cameraEnabled = true;
    }

    function centerOnPlayer() {
      // Get player's center position in world coordinates
      const playerCenterX = playerX + (cellSize / 2);
      const playerCenterY = playerY + (cellSize / 2);
      
      // Calculate where to position the canvas so player appears at screen center
      const screenCenterX = window.innerWidth / 2;
      const screenCenterY = window.innerHeight / 2;
      
      // Simple formula: translate = (screenCenter / zoom) - playerCenter
      cameraX = (screenCenterX / currentZoom) - playerCenterX;
      cameraY = (screenCenterY / currentZoom) - playerCenterY;
      
      // Apply the transform immediately
      applyCamera();
    }

    function applyCamera() {
      // Batch transform application - single transform string
      const transform = `scale(${currentZoom}) translate(${cameraX}px, ${cameraY}px)`;
      canvas.style.transform = transform;
      canvas.style.transformOrigin = '0 0';
    }

    function updateCamera() {
      if (!cameraEnabled || cameraUpdatePending) return;
      
      cameraUpdatePending = true;
      requestAnimationFrame(() => {
        centerOnPlayer(); // This already calls applyCamera()
        cameraUpdatePending = false;
      });
    }
    
    // Batched update function - combines camera and render
    function updateCameraAndRender() {
      if (cameraEnabled) {
        updateCamera();
      }
      renderFrame();
    }

    // Replace the old camera functions
    function zoomInOnPlayer() {
      initializeNewCamera();
    }

    function centerCameraOnPlayer() {
      centerOnPlayer();
    }

    function updateCameraPosition() {
      updateCamera();
    }

    function resetCamera() {
      cameraEnabled = false;
      currentZoom = 1.0;
      cameraX = 0;
      cameraY = 0;
      // Force reset the canvas transform
      canvas.style.transform = 'scale(1) translate(0px, 0px)';
      canvas.style.transformOrigin = '0 0';
      // Clear any existing transforms
      canvas.style.webkitTransform = 'scale(1) translate(0px, 0px)';
    }

    // Remove all the old camera animation complexity
    function startCameraAnimation() {
      // No animation needed - camera updates instantly
      updateCamera();
    }

    // Setup predefined maze
    mazeStructure = predefinedMaze;
    
    // Set start and end positions for the predefined maze
    startRow = 2;  // In the expanded wide path area (top-left)
    startCol = 2;
    endRow = 46;   // Bottom right corner (last row - 1)
    endCol = 46;   // Bottom right corner (last column - 1)
    
    // CRITICAL: Prevent any changes to start position
    Object.defineProperty(window, 'startRow', {
      value: 2,
      writable: false,
      configurable: false
    });
    Object.defineProperty(window, 'startCol', {
      value: 2,
      writable: false,
      configurable: false
    });
    
    // IMMEDIATE FORCE RESET player position to starting position (BEFORE ANY OTHER CODE)
    // EXPLICIT reset with logging
    playerX = startCol * cellSize;
    playerY = startRow * cellSize;
    
    // Don't call createMaze since we're using our own Canvas rendering
    // myLibrary.createMaze();

    // Create a virtual player object that mimics DOM behavior for library compatibility
    var player = {
      style: {
        get top() { 
          return playerY + "px"; 
        },
        set top(value) { 
          const newY = parseInt(value);
          playerY = newY;
          // Don't trigger camera/render immediately - let movement system batch updates
        },
        get left() { 
          return playerX + "px"; 
        },
        set left(value) { 
          const newX = parseInt(value);
          playerX = newX;
          // Don't trigger camera/render immediately - let movement system batch updates
        }
      }
    };
    
    // Initialize the canvas rendering system
    function initializeGame() {
      // FORCE RESET all state variables
      playerIsMoving = false;
      
      // FORCE RESET player position to starting position
      playerX = startCol * cellSize;
      playerY = startRow * cellSize;
      
      // Force a complete camera reset first
      resetCamera();
      
      // Force initial render to ensure maze is visible
      renderFrame();
      prepareAnimationSystem();
      
      // Initialize new camera system after reset
      setTimeout(() => {
        initializeNewCamera();
        // Force another render to ensure everything is visible
        renderFrame();
        
        // Start lazy audio loading AFTER maze is fully initialized
        setTimeout(() => {
          preloadAudioAsync();
        }, 100); // Additional delay to ensure smooth maze startup
      }, 50); // Small delay to ensure reset is complete
    }
    
    // Force complete reset on page load
    window.addEventListener('load', function() {
      resetCamera();
      initializeGame();
      
      // Start audio loading after page is fully loaded and maze is initialized
      setTimeout(() => {
        if (!audioPreloaded && !audioLoadingInProgress) {
          preloadAudioAsync();
        }
      }, 200); // Ensure maze has time to fully initialize
    });
    
    // No need to wait for sprite loading - initialize immediately
    initializeGame();

  // Add 'y' key handler to log player position for manual bounds testing
  window.addEventListener("keydown", (event) => {
    if (event.key === "y" || event.key === "Y") {
      // Calculate player's grid position
      const playerGridRow = Math.round(playerY / cellSize);
      const playerGridCol = Math.round(playerX / cellSize);
      const mazeCenter = Math.round(mazeSize / 2);
      const distanceFromCenter = Math.sqrt(Math.pow(playerGridRow - mazeCenter, 2) + Math.pow(playerGridCol - mazeCenter, 2));
      
      console.log(`Player Position: Row ${playerGridRow}, Col ${playerGridCol} (distance from center: ${distanceFromCenter.toFixed(2)})`);
      return;
    }
    
    if (event.key.includes("Arrow") || event.key === "w" || event.key === "a" || event.key === "s" || event.key === "d") {
      event.preventDefault();
      
      // Start timer and music only once
      if (!interval) {
        interval = true;
        const { startTime: capturedStartTime, interval: capturedInterval } = myLibrary.startTimer(timerElement);
        startTime = capturedStartTime;
      }
      if (first === 0) {
        // Smart music playback - play immediately if loaded, queue if still loading
        if (audioPreloaded && !musicStarted) {
          // Audio ready - start music immediately
          setTimeout(() => {
            try {
              myLibrary.playMusic();
              musicStarted = true;
              console.log('Music started successfully');
            } catch (error) {
              console.warn('Music playback failed:', error);
            }
          }, 0);
        } else if (!musicStarted) {
          // Audio not ready - set up a check to start music when available
          console.log('Audio still loading, will start music when ready...');
          const checkAudioInterval = setInterval(() => {
            if (audioPreloaded && !musicStarted) {
              try {
                myLibrary.playMusic();
                musicStarted = true;
                console.log('Music started after audio loading completed');
                clearInterval(checkAudioInterval);
              } catch (error) {
                console.warn('Music playback failed:', error);
                clearInterval(checkAudioInterval);
              }
            }
          }, 100);
          
          // Safety timeout to prevent infinite checking (stop trying after 10 seconds)
          setTimeout(() => {
            if (!musicStarted) {
              console.warn('Audio loading timeout - continuing without music');
              clearInterval(checkAudioInterval);
            }
          }, 10000);
        }
        first++;
      }
      
      // COMMENTED OUT - Update player direction for animation (no longer needed)
      // if (event.key === "ArrowUp" || event.key === "w") {
      //   playerDirection = 'up';
      // } else if (event.key === "ArrowDown" || event.key === "s") {
      //   playerDirection = 'down';
      // } else if (event.key === "ArrowLeft" || event.key === "a") {
      //   playerDirection = 'left';
      // } else if (event.key === "ArrowRight" || event.key === "d") {
      //   playerDirection = 'right';
      // }
      
      // COMMENTED OUT - Start animation immediately for responsive feel
      // startAnimation();
      
      // Mark player as moving and update camera
      playerIsMoving = true;
      
      // Only process if this key wasn't already pressed (prevents auto-repeat)
      if (!keysPressed[event.key]) {
        // Mark key as pressed
        keysPressed[event.key] = true;
        
        // Immediate movement on first keypress
        myLibrary.movePlayer(event, endScreen, startTime, endContent, type, personalbest, newpersonalbest, interval);
        
        // Single batched camera and render update after movement
        updateCameraAndRender();
        
        // Start continuous movement after a delay if key is still held
        if (!movementInterval) {
          setTimeout(() => {
            if (keysPressed[event.key]) {
              startContinuousMovement();
            }
          }, 100); // Small delay before continuous movement starts
        }
      }
    }
  });

  window.addEventListener("keyup", (event) => {
    if (event.key.includes("Arrow") || event.key === "w" || event.key === "a" || event.key === "s" || event.key === "d") {
      // Mark key as released
      keysPressed[event.key] = false;
      
      // Check if any movement keys are still pressed
      const movementKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"];
      const anyKeyPressed = movementKeys.some(key => keysPressed[key]);
      
      // Stop continuous movement if no keys are pressed
      if (!anyKeyPressed) {
        playerIsMoving = false; // Mark player as stopped
        if (movementInterval) {
          clearInterval(movementInterval);
          movementInterval = null;
          currentDirection = null;
        }
      }
    }
  });

  function startContinuousMovement() {
    movementInterval = setInterval(() => {
      // Determine current direction based on pressed keys
      let direction = null;
      
      if (keysPressed["ArrowUp"] || keysPressed["w"]) {
        direction = "up";
      } else if (keysPressed["ArrowDown"] || keysPressed["s"]) {
        direction = "down";
      } else if (keysPressed["ArrowLeft"] || keysPressed["a"]) {
        direction = "left";
      } else if (keysPressed["ArrowRight"] || keysPressed["d"]) {
        direction = "right";
      }
      
      if (direction) {
        // Create a synthetic event for the movement
        const syntheticEvent = {
          key: direction === "up" ? "ArrowUp" : 
               direction === "down" ? "ArrowDown" :
               direction === "left" ? "ArrowLeft" : "ArrowRight",
          preventDefault: () => {}
        };
        
        myLibrary.movePlayer(syntheticEvent, endScreen, startTime, endContent, type, personalbest, newpersonalbest, interval);
        
        // Single batched camera and render update after movement
        updateCameraAndRender();
      } else {
        // No keys pressed, stop movement
        playerIsMoving = false; // Mark player as stopped
        clearInterval(movementInterval);
        movementInterval = null;
        currentDirection = null;
      }
    }, 75); // Slower continuous movement for better performance (was 50ms)
  }
    restartButton.addEventListener("click", function() {
      resetCamera();
      myLibrary.restartMaze();
    });
    backButton.addEventListener("click", myLibrary.goBack);

    backButton.style.display = "inline-block";
    backButton.addEventListener("click", myLibrary.hideEndScreen);
    
    // Set the appropriate copy function based on mode
    if (easy) {
      document.getElementById("copy-button").addEventListener("click", myLibrary.copyEasyMazeAndTime);
    } else {
      document.getElementById("copy-button").addEventListener("click", myLibrary.copyMazeAndTime);
    }
    
    // Handle window resize to recalculate maze size
    function resizeMaze() {
      // Recalculate the maximum possible cell size to fill the screen
      const availableWidth = window.innerWidth;
      const availableHeight = window.innerHeight;
      
      // Calculate cell size based on screen dimensions and maze size
      const maxCellSizeWidth = Math.floor(availableWidth / mazeSize);
      const maxCellSizeHeight = Math.floor(availableHeight / mazeSize);
      
      // Use the smaller of the two to ensure the maze fits in both dimensions
      cellSize = Math.min(maxCellSizeWidth, maxCellSizeHeight);
      
      // Ensure minimum cell size for playability
      if (cellSize < 3) {
        cellSize = 3;
      }
      
      // Calculate actual maze dimensions in pixels
      const mazeWidthPx = mazeSize * cellSize;
      const mazeHeightPx = mazeSize * cellSize;
      
      // Update canvas size
      canvas.width = mazeWidthPx;
      canvas.height = mazeHeightPx;
      
      // Update container size
      mazeContainer.style.width = mazeWidthPx + 'px';
      mazeContainer.style.height = mazeHeightPx + 'px';
      
      // Update player position to match new cell size
      const currentCol = Math.round(playerX / (canvas.width / mazeSize));
      const currentRow = Math.round(playerY / (canvas.height / mazeSize));
      playerX = currentCol * cellSize;
      playerY = currentRow * cellSize;
      
      // Re-calculate zoom and camera position for new dimensions
      if (cameraEnabled) {
        // Recalculate zoom scale for new screen size
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const smallerDimension = Math.min(viewportWidth, viewportHeight);
        const targetCellsVisible = 12;
        currentZoom = Math.max(1.5, Math.min(4.0, smallerDimension / (targetCellsVisible * cellSize)));
        
        // Re-center camera on player
        centerOnPlayer();
      }
      
      // Re-render the maze
      renderFrame();
    }
    
    // Add resize event listener with debouncing
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(resizeMaze, 100);
    });
  </script>
</body>
</html>
