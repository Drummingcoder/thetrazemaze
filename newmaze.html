<!DOCTYPE html>
<html>
<head>
  <title>The Traze Maze</title>
  <link rel="icon" type="icon/x-image" href="logo.jpg">
  <link rel="stylesheet" type="text/css" href="mazestyle.css">
  <style>
    /* End screen color scheme to match maze */
    #end-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, rgba(35, 40, 55, 0.92) 0%, rgba(45, 50, 65, 0.92) 100%);
      color: #C0C0C0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      font-weight: bold;
      z-index: 2000;
      border: none;
      box-shadow: none;
      text-align: center;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    #end-screen h2 {
      color: #FF1744; /* Red to match end square */
      margin-bottom: 12px;
      font-size: 26px;
      font-weight: bold;
      text-shadow: 0 2px 8px rgba(183, 28, 28, 0.3);
    }

    #end-time-taken {
      color: #C0C0C0; /* Silver text */
      font-size: 20px;
      margin-bottom: 10px;
      font-weight: bold;
    }

    #personal-best {
      color: #FF1744; /* Red accent for best time */
      font-size: 16px;
      margin-bottom: 8px;
      font-weight: bold;
    }

    #new-personal-best {
      color: #FF5252; /* Lighter red accent */
      font-size: 16px;
      margin-bottom: 8px;
      font-weight: bold;
    }

    #end-screen button {
      background: linear-gradient(135deg, #7B7F85 0%, #C0C0C0 100%);
      color: #232837;
      border: 2px solid #A0A4AA;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 16px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      margin: 8px 0;
      box-shadow: 0 2px 8px rgba(123, 127, 133, 0.15);
      cursor: pointer;
      transition: background 0.3s, border 0.3s;
    }

    #end-screen button:hover {
      background: linear-gradient(135deg, #FF1744 0%, #B71C1C 100%);
      color: #C0C0C0;
      border-color: #B71C1C;
    }
    body {
      text-align: center;
      background: linear-gradient(135deg, 
        rgba(25, 30, 45, 0.98) 0%, 
        rgba(35, 40, 55, 0.96) 50%, 
        rgba(45, 50, 65, 0.98) 100%);
      background-size: 100% 100%;
      background-attachment: fixed;
      position: relative;
      overflow-x: hidden;
      /* Removed expensive animation for better performance */
    }
    
    /* Simplified atmospheric background - much better performance */
    @keyframes subtleGlow {
      0% { opacity: 0.95; }
      50% { opacity: 1.0; }
      100% { opacity: 0.95; }
    }
    
    /* Optional: Add a very subtle animation only if needed */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 20% 30%, rgba(70, 80, 120, 0.1) 0%, transparent 50%);
      animation: subtleGlow 8s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    /* COMMENTED OUT - Two large waving stickmen on sides of maze - optimized for performance */
    /*
    .waving-stickman {
      position: fixed;
      width: 96px;
      height: 96px;
      background-image: url('waving-stickman-spritesheet.png');
      background-size: 288px 96px;
      background-repeat: no-repeat;
      background-position: 0 0;
      pointer-events: none;
      z-index: -1;
      opacity: 0.9;
      image-rendering: pixelated;
      will-change: background-position;
    }
    
    .stickman-left { 
      top: 50%; 
      left: 5%; 
      transform: translateY(-50%);
      animation: waveFrames 2.0s steps(3) infinite; 
    }
    .stickman-right { 
      top: 50%; 
      right: 5%; 
      transform: translateY(-50%);
      animation: waveFrames 2.2s steps(3) infinite 0.5s;
    }
    
    @keyframes waveFrames {
      0% { background-position: 0 0; }
      33.33% { background-position: -96px 0; }
      66.66% { background-position: -192px 0; }
      100% { background-position: 0 0; }
    }
    */

    #timer {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #FFFFFF;
      padding: 12px 18px;
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      font-weight: bold;
      z-index: 1000;
      border: 2px solid #E1BEE7;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    #dash-indicator {
      position: fixed;
      top: 80px; /* Below the timer with more space */
      right: 20px;
      background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);
      color: #FFFFFF;
      padding: 8px 12px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      font-weight: bold;
      z-index: 1000;
      border: 2px solid #10B981; /* Green border when ready */
      box-shadow: 0 3px 12px rgba(16, 185, 129, 0.4);
      transition: all 0.3s ease;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    #dash-indicator.cooldown {
      background: linear-gradient(135deg, #FF6B6B 0%, #EE5A52 100%);
      border-color: #EF4444; /* Red border when on cooldown */
      box-shadow: 0 3px 12px rgba(239, 68, 68, 0.4);
      color: #FFFFFF;
    }

    #ground-pound-indicator {
      position: fixed;
      top: 130px; /* Moved up to replace jump indicator position */
      right: 20px;
      background: linear-gradient(135deg, #FF8A80 0%, #FF5722 100%);
      color: #FFFFFF;
      padding: 8px 12px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      font-weight: bold;
      z-index: 1000;
      border: 2px solid #DC2626; /* Red border for ground pound */
      box-shadow: 0 3px 12px rgba(220, 38, 38, 0.4);
      transition: all 0.3s ease;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    #ground-pound-indicator.cooldown {
      background: linear-gradient(135deg, #FFEAA7 0%, #F59E0B 100%);
      border-color: #F59E0B; /* Orange border when on cooldown */
      box-shadow: 0 3px 12px rgba(245, 158, 11, 0.4);
      color: #1F2937; /* Dark text for better contrast on yellow */
    }

    #ground-pound-indicator.active {
      background: linear-gradient(135deg, #FF1744 0%, #B91C1C 100%);
      border-color: #B91C1C; /* Dark red border when ground pounding */
      box-shadow: 0 3px 15px rgba(185, 28, 28, 0.6);
      color: #FFFFFF;
      animation: pulse-red 0.3s infinite alternate;
    }

    #ground-pound-indicator.disabled {
      background: linear-gradient(135deg, #9CA3AF 0%, #6B7280 100%);
      border-color: #6B7280; /* Gray border when disabled */
      box-shadow: 0 3px 12px rgba(107, 114, 128, 0.3);
      color: #D1D5DB; /* Light gray text */
    }

    #jump-charge-indicator {
      position: fixed;
      background: linear-gradient(135deg, #FFEAA7 0%, #F59E0B 50%, #FF8C00 100%);
      color: #000000;
      padding: 6px 10px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      font-weight: bold;
      z-index: 999; /* Behind player but above maze */
      border: 2px solid #F59E0B;
      box-shadow: 0 3px 10px rgba(245, 158, 11, 0.5);
      transition: all 0.1s ease;
      pointer-events: none; /* Don't interfere with game interaction */
      opacity: 0; /* Hidden by default */
      transform: translateX(-50%) translateY(-50%); /* Center on position */
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
    }

    #jump-charge-indicator.visible {
      opacity: 1;
      animation: chargePulse 0.5s ease-in-out infinite alternate;
    }

    @keyframes chargePulse {
      0% { 
        box-shadow: 0 3px 10px rgba(245, 158, 11, 0.5);
        transform: translateX(-50%) translateY(-50%) scale(1);
      }
      100% { 
        box-shadow: 0 5px 15px rgba(245, 158, 11, 0.8);
        transform: translateX(-50%) translateY(-50%) scale(1.05);
      }
    }

    @keyframes pulse-red {
      from { transform: scale(1); opacity: 0.8; }
      to { transform: scale(1.05); opacity: 1; }
    }

    #controls-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(30, 58, 95, 0.95);
      color: #FFFFFF;
      padding: 15px 20px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      z-index: 2000;
      border: 2px solid #F59E0B; /* Orange border to match theme */
      box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
      text-align: center;
      max-width: 80%;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    #controls-hint.hidden {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.9);
      pointer-events: none;
    }

    #debug-console {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 400px;
      max-height: 300px;
      background-color: rgba(0, 0, 0, 0.9);
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      border: 2px solid #333;
      border-radius: 5px;
      padding: 10px;
      overflow-y: auto;
      z-index: 3000;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #debug-console .debug-entry {
      margin-bottom: 2px;
      border-bottom: 1px solid #333;
      padding-bottom: 2px;
    }

    #debug-console .debug-timestamp {
      color: #888;
      font-size: 10px;
    }

    #debug-console .debug-error {
      color: #ff4444;
    }

    #debug-console .debug-warn {
      color: #ffaa00;
    }

    #debug-console .debug-info {
      color: #4488ff;
    }

    #maze-container {
      position: relative;
      overflow: hidden;
      background: transparent; /* Removed white background */
      border: none; /* Removed border that created white square effect */
      border-radius: 0;
      box-shadow: none; /* Removed shadow */
      /* Performance optimizations */
      will-change: transform;
      transform: translateZ(0); /* Force GPU acceleration */
      backface-visibility: hidden;
      /* Dynamic sizing will be applied via JavaScript */
    }

    #maze-canvas {
      display: block;
      image-rendering: pixelated; /* Keep crisp edges */
      /* Performance optimizations for canvas */
      will-change: transform;
      transform: translateZ(0); /* Force GPU acceleration */
      backface-visibility: hidden;
      /* Dynamic sizing and positioning will be applied via JavaScript */
    }
    
    /* Preload critical images */
    body::after {
      content: '';
      position: absolute;
      left: -9999px;
      background-image: url('stickman-running-spritesheet.png'), url('waving-stickman-spritesheet.png');
    }

    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000000;
      z-index: 5000;
      opacity: 1;
      transition: opacity 0.4s ease;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- Black loading screen overlay -->
  <div id="loading-overlay"></div>
  <!-- COMMENTED OUT - Two large waving stickmen on either side of the maze -->
  <!-- <div class="waving-stickman stickman-left"></div> -->
  <!-- <div class="waving-stickman stickman-right"></div> -->
  
  <div id="timer">00:00.000</div>
  <div id="dash-indicator">Dash Ready</div>
  <div id="ground-pound-indicator">Ground Pound Ready</div>
  <div id="controls-hint">Arrow Keys/WASD: Move | Shift/Space: Dash | Hold Up/W: Charge Jump | Down/S (in air): Ground Pound</div>
  <!-- <div id="debug-console"></div> -->
  <div id="maze-container">
    <canvas id="maze-canvas"></canvas>
    <canvas id="player-canvas"></canvas>
  </div>

  <div id="end-screen" class="hidden">
  <button id="back-button">Back</button>
  <h2 id="end-content">Congratulations!</h2>

  <div id="end-time-taken"></div>
  <div id="personal-best">
    Personal Best: <span id="best-time"></span>
  </div>
  <div id="new-personal-best" style = "display:block;">Personal New Best!</div>

    <button id="restart-button">Restart Maze</button>
  </div>
  
  <!-- Modular JavaScript Files - Load in dependency order -->
  <script src="./js/audio-manager.js"></script>
  <script src="./js/game-timer.js"></script>
  <script src="./js/personal-best-manager.js"></script>
  <script src="./js/maze-generator.js"></script>
  <script src="./js/maze-renderer.js"></script>
  <script src="./js/camera-system.js"></script>
  <script src="./js/player-animation.js"></script>
  <script src="./js/canvas-renderer.js"></script>
  <script src="./js/player-controller.js"></script>
  <script src="./js/game-initializer.js"></script>
  <script src="./js/game-actions.js"></script>
  <script src="./js/main-library.js"></script>

  <script>
    // Show black loading overlay and fade out after 0.75s
    window.addEventListener('DOMContentLoaded', function() {
      var loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
        setTimeout(function() {
          loadingOverlay.style.opacity = '0';
          setTimeout(function() {
            loadingOverlay.style.display = 'none';
          }, 400);
        }, 750);
      }
    });
    // =================================================================
    // DEBUG CONSOLE SYSTEM
    // =================================================================
    window.debugLog = function(message, type = 'info') {
      const debugConsole = document.getElementById('debug-console');
      if (!debugConsole) return;
      
      const timestamp = new Date().toLocaleTimeString() + '.' + String(new Date().getMilliseconds()).padStart(3, '0');
      const entry = document.createElement('div');
      entry.className = `debug-entry debug-${type}`;
      entry.innerHTML = `<span class="debug-timestamp">[${timestamp}]</span> ${message}`;
      
      debugConsole.appendChild(entry);
      
      // Auto-scroll to bottom
      debugConsole.scrollTop = debugConsole.scrollHeight;
      
      // Keep only last 100 entries to prevent memory issues
      const entries = debugConsole.querySelectorAll('.debug-entry');
      if (entries.length > 100) {
        entries[0].remove();
      }
    };

    // Clear debug console function
    window.clearDebug = function() {
      const debugConsole = document.getElementById('debug-console');
      if (debugConsole) debugConsole.innerHTML = '';
    };

    // =================================================================
    // MAIN GAME INITIALIZATION AND COORDINATION
    // =================================================================
    // This script coordinates the various JavaScript modules and handles
    // game-specific setup. Most game logic has been moved to modules:
    // - Camera functions → js/camera-system.js
    // - Rendering functions → js/canvas-renderer.js  
    // - Player movement → js/player-controller.js
    // - Game initialization → js/game-initializer.js
    // =================================================================
    
    // FORCE CLEAR all browser storage to prevent any data persistence between sessions
    try {
      sessionStorage.clear();
      // Don't clear localStorage as it contains best times
    } catch (e) {
      // Silently handle storage errors
    }
    
    // Lazy audio loading system - loads audio after maze initialization
    let audioPreloaded = false;
    let musicStarted = false;
    let audioLoadingInProgress = false;
    let audioCheckInterval = null; // Global audio check interval tracker

    function preloadAudioAsync() {
      if (audioPreloaded || audioLoadingInProgress) return;
      
      audioLoadingInProgress = true;
      console.log('Starting lazy audio preload...');
      
      // Use setTimeout to prevent blocking the main thread
      setTimeout(() => {
        try {
          // Use AudioManager directly instead of myLibrary
          if (window.AudioManager) {
            console.log('Calling AudioManager.preloadAudio()...');
            window.AudioManager.preloadAudio();
            
            // Add event listeners to check if audio actually loads
            if (window.AudioManager.preloadedAudio) {
              window.AudioManager.preloadedAudio.addEventListener('canplaythrough', () => {
                audioPreloaded = true;
                audioLoadingInProgress = false;
                console.log('Audio preloaded successfully via AudioManager - canplaythrough event');
              });
              
              window.AudioManager.preloadedAudio.addEventListener('error', (e) => {
                console.error('Audio loading error:', e);
                audioPreloaded = false;
                audioLoadingInProgress = false;
              });
              
              // Fallback timeout - mark as loaded after 2 seconds even if no event fires
              setTimeout(() => {
                if (audioLoadingInProgress) {
                  console.log('Audio preload timeout - assuming loaded');
                  audioPreloaded = true;
                  audioLoadingInProgress = false;
                }
              }, 2000);
            } else {
              console.warn('AudioManager.preloadedAudio is null after preloadAudio call');
              audioPreloaded = false;
              audioLoadingInProgress = false;
            }
          } else {
            console.warn('AudioManager not available, trying myLibrary fallback');
            myLibrary.preloadAudio();
            audioPreloaded = true;
            audioLoadingInProgress = false;
            console.log('Audio preloaded successfully via myLibrary');
          }
        } catch (error) {
          console.warn('Audio preload failed:', error);
          audioPreloaded = false;
          audioLoadingInProgress = false;
        }
      }, 150); // Small delay to ensure maze is fully rendered first
    }

    // Preload assets immediately when script loads
    window.addEventListener('DOMContentLoaded', function() {
      // Only preload images immediately - audio will be loaded later
      const preloadImages = ['stickman-running-spritesheet.png', 'waving-stickman-spritesheet.png'];
      preloadImages.forEach(src => {
        const img = new Image();
        img.src = src;
        img.style.display = 'none';
        document.body.appendChild(img);
      });
    });
 
  var searchParams = new URLSearchParams(window.location.search);
  var type = searchParams.get('type');
  var multiple = searchParams.get('multiple');
  var difficulty = searchParams.get('difficulty') || 'medium'; // Default to medium if not specified
  var mode = searchParams.get('mode') || 'hard'; // Default to hard mode if not specified
  
  // Complex navigable maze with 4x4 path areas and 2x2 walls - designed for challenge and fun (1 = wall, 0 = path)
  const predefinedMaze = [
     [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,1,1,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,3,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,2,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,3,1,1,0,0,0,0,0,0,0,0,0,3,1,1,3,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,3,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,1,0,0,0,0,1,1,0,0,2,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,3,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,2,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,3,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  
  // Set maze size based on predefined maze
  mazeSize = predefinedMaze.length;
  
  // Calculate the maximum possible cell size to fill the screen
  const availableWidth = window.innerWidth;
  const availableHeight = window.innerHeight;
  
  // Calculate cell size based on screen dimensions and maze size
  const maxCellSizeWidth = Math.floor(availableWidth / mazeSize);
  const maxCellSizeHeight = Math.floor(availableHeight / mazeSize);
  
  // Use the smaller of the two to ensure the maze fits in both dimensions
  cellSize = Math.min(maxCellSizeWidth, maxCellSizeHeight);
  
  // Ensure minimum cell size for playability (but don't limit maximum)
  if (cellSize < 3) {
    cellSize = 3; // Minimum viable cell size
  }
  
  // Calculate actual maze dimensions in pixels
  const mazeWidthPx = mazeSize * cellSize;
  const mazeHeightPx = mazeSize * cellSize;
  
  // Set easy flag based on mode
  var easy = (mode === 'easy'); // Make global for library.js
  
  // Apply dynamic styling
  const mazeContainer = document.getElementById("maze-container");
  const canvas = document.getElementById("maze-canvas");
  const ctx = canvas.getContext("2d");
  const playerCanvas = document.getElementById("player-canvas");
  const playerCtx = playerCanvas.getContext("2d");
  
  // Set canvas sizes to the actual maze size
  canvas.width = mazeWidthPx;
  canvas.height = mazeHeightPx;
  playerCanvas.width = mazeWidthPx;
  playerCanvas.height = mazeHeightPx;
  
  // Configure maze canvas for crisp geometric rendering
  ctx.imageSmoothingEnabled = false; // Pixelated for crisp maze edges
  
  // Configure player canvas for smooth sprite rendering
  playerCtx.imageSmoothingEnabled = true;
  playerCtx.imageSmoothingQuality = 'high';
  if (playerCtx.webkitImageSmoothingEnabled !== undefined) playerCtx.webkitImageSmoothingEnabled = true;
  if (playerCtx.mozImageSmoothingEnabled !== undefined) playerCtx.mozImageSmoothingEnabled = true;
  if (playerCtx.msImageSmoothingEnabled !== undefined) playerCtx.msImageSmoothingEnabled = true;
  if (playerCtx.oImageSmoothingEnabled !== undefined) playerCtx.oImageSmoothingEnabled = true;
  
  // Set canvas size to the actual maze size
  canvas.width = mazeWidthPx;
  canvas.height = mazeHeightPx;
  
  // Make the container fill the screen and center the maze
  const style = document.createElement('style');
  style.textContent = `
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      min-height: 100vh;
      min-width: 100vw;
    }
    #maze-container {
      width: ${mazeWidthPx}px;
      height: ${mazeHeightPx}px;
      position: absolute;
      top: 0;
      left: 0;
      overflow: visible;
    }
    #maze-canvas {
      display: block;
      image-rendering: pixelated; /* Crisp edges for maze geometry */
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1; /* Behind player */
    }
    #player-canvas {
      display: block;
      image-rendering: auto; /* Smooth rendering for player sprite */
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 3; /* Well above maze */
      pointer-events: none; /* Allow clicks to pass through to maze */
    }
  `;
  document.head.appendChild(style);

    var maze = document.getElementById("maze-container"); // Make global for library.js
    const timerElement = document.getElementById("timer");
    const endScreen = document.getElementById("end-screen");
    const restartButton = document.getElementById("restart-button");
    const backButton = document.getElementById("back-button");
    const endContent = document.getElementById("end-time-taken");
    const personalbest = document.getElementById("personal-best");
    const newpersonalbest = document.getElementById("new-personal-best");

    // Make all variables global for module access
    window.maze = maze;
    window.timerElement = timerElement;
    window.endScreen = endScreen;
    window.restartButton = restartButton;
    window.backButton = backButton;
    window.endContent = endContent;
    window.personalbest = personalbest;
    window.newpersonalbest = newpersonalbest;
    window.mazeContainer = mazeContainer;
    window.canvas = canvas;
    window.ctx = ctx;
    window.playerCanvas = playerCanvas;
    window.playerCtx = playerCtx;

    var mazeStructure, startRow, startCol, endRow, endCol; // Make global for library.js
    let time = 0;
    let interval = false, startTime, startMaze;
    let first = 0;
    var mazecount = 0; // Make global for library.js
    
    // Canvas rendering system - smooth pixel-based movement system
    // FORCE RESET to 0 to prevent any persistence across reloads
    let playerX = 0, playerY = 0; // Player position in pixels - EXPLICITLY RESET TO 0
    
    // Make all maze and player variables global for module access
    window.mazeStructure = mazeStructure;
    window.startRow = startRow;
    window.startCol = startCol;
    window.endRow = endRow;
    window.endCol = endCol;
    window.mazeSize = mazeSize;
    window.cellSize = cellSize;
    window.playerX = playerX;
    window.playerY = playerY;
    window.time = time;
    window.interval = interval;
    window.startTime = startTime;
    window.first = first;
    window.mazecount = mazecount;
    window.type = type;
    window.easy = easy;
    window.audioCheckInterval = audioCheckInterval;
    
    // Smooth movement system variables (keep some references for compatibility)
    let playerIsMoving = false;
    let movementSpeed = 6; // Increased from 3 to 6 pixels per frame for faster movement
    let smoothMovementKeys = {};
    let animationFrameId = null;
    
    // Bridge functions to connect modules with remaining inline code
    function updateCameraAndRender() {
      if (window.CameraSystem && window.CameraSystem.cameraEnabled) {
        window.CameraSystem.updateCamera();
      }
      if (window.CanvasRenderer) {
        window.CanvasRenderer.renderFrame();
      }
    }
    
    function cleanupGameSystems() {
      if (window.GameInitializer) {
        window.GameInitializer.cleanupGameSystems();
      }
    }
    
    // Collision detection and end checking moved to PlayerController module
    
    // Smooth movement animation loop moved to PlayerController module
    
    // Cleanup functions moved to GameInitializer module
    
    // Camera system moved to CameraSystem module
    let cameraX = 0;
    let cameraY = 0;
    let currentZoom = 1.0;
    let cameraEnabled = false;
    
    // Canvas rendering system moved to CanvasRenderer module
    let renderPending = false;
    let lastRenderTime = 0;
    const RENDER_THROTTLE = 16; // 60 FPS max for smoother movement
    let renderQueued = false;
    
    // drawMaze and drawPlayer functions moved to CanvasRenderer module

    // renderFrame and related functions moved to CanvasRenderer module
    
    // Camera functions moved to CameraSystem module
    let cameraUpdatePending = false;

    // Setup predefined maze
    mazeStructure = predefinedMaze;
    
    // Set start and end positions for the predefined maze
    startRow = 2;  // In the expanded wide path area (top-left)
    startCol = 2;
    endRow = 46;   // Bottom right corner (last row - 1)
    endCol = 46;   // Bottom right corner (last column - 1)
    
    // Update global variables after assignment
    window.mazeStructure = mazeStructure;
    window.startRow = startRow;
    window.startCol = startCol;
    window.endRow = endRow;
    window.endCol = endCol;
    window.mazeSize = mazeSize;
    window.cellSize = cellSize;
    
    // CRITICAL: Prevent any changes to start position
    Object.defineProperty(window, 'startRow', {
      value: 2,
      writable: false,
      configurable: false
    });
    Object.defineProperty(window, 'startCol', {
      value: 2,
      writable: false,
      configurable: false
    });
    
    // IMMEDIATE FORCE RESET player position to starting position (BEFORE ANY OTHER CODE)
    // EXPLICIT reset with logging
    playerX = startCol * cellSize;
    playerY = startRow * cellSize;
    
    // Update global player position
    window.playerX = playerX;
    window.playerY = playerY;
    
    // Don't call createMaze since we're using our own Canvas rendering
    // myLibrary.createMaze();

    // Create a virtual player object that mimics DOM behavior for library compatibility
    var player = {
      style: {
        get top() { 
          return window.playerY + "px"; 
        },
        set top(value) { 
          const newY = parseInt(value);
          window.playerY = newY;
          // Don't trigger camera/render immediately - let movement system batch updates
        },
        get left() { 
          return window.playerX + "px"; 
        },
        set left(value) { 
          const newX = parseInt(value);
          window.playerX = newX;
          // Don't trigger camera/render immediately - let movement system batch updates
        }
      }
    };
    
    // Make player global
    window.player = player;
    
    // Initialize the canvas rendering system
    function initializeGame() {
      if (window.GameInitializer) {
        window.GameInitializer.initializeGame();
        
        // Ensure virtual player is created
        if (window.GameInitializer.createVirtualPlayer) {
          const virtualPlayer = window.GameInitializer.createVirtualPlayer();
          if (virtualPlayer) {
            window.player = virtualPlayer;
          }
        }
      } else {
        // Fallback initialization if module not loaded
        console.warn('GameInitializer module not loaded, using fallback');
        if (window.CameraSystem) {
          window.CameraSystem.resetCamera();
        }
        if (window.CanvasRenderer) {
          window.CanvasRenderer.renderFrame();
        }
      }
      
      // Start the smooth movement system
      if (window.PlayerController && window.PlayerController.startSmoothMovement) {
        window.PlayerController.startSmoothMovement();
      }
      
      // Initialize performance monitoring
      if (window.CanvasRenderer && window.CanvasRenderer.monitorPerformance) {
        window.CanvasRenderer.monitorPerformance();
      }
      
      // Prepare animation system
      if (window.CanvasRenderer && window.CanvasRenderer.prepareAnimationSystem) {
        window.CanvasRenderer.prepareAnimationSystem();
      }
    }
    
    // Force complete reset on page load
    window.addEventListener('load', function() {
      if (window.CameraSystem) {
        window.CameraSystem.resetCamera();
      }
      initializeGame();
      
      // Start audio loading after page is fully loaded and maze is initialized
      setTimeout(() => {
        console.log('Checking audio loading conditions...');
        console.log('audioPreloaded:', audioPreloaded);
        console.log('audioLoadingInProgress:', audioLoadingInProgress);
        console.log('AudioManager available:', !!window.AudioManager);
        console.log('myLibrary available:', !!window.myLibrary);
        
        if (typeof audioPreloaded !== 'undefined' && !audioPreloaded && typeof audioLoadingInProgress !== 'undefined' && !audioLoadingInProgress) {
          if (window.GameInitializer) {
            console.log('Starting audio preload via GameInitializer...');
            window.GameInitializer.preloadAudioAsync();
          } else {
            console.log('Starting audio preload via local function...');
            preloadAudioAsync(); // Fallback to local function
          }
        } else {
          console.log('Audio loading conditions not met - skipping preload');
        }
      }, 200); // Ensure maze has time to fully initialize
    });
    
    // Add missing resize handler
    window.addEventListener('resize', function() {
      if (window.GameInitializer && window.GameInitializer.resizeMaze) {
        window.GameInitializer.resizeMaze();
      }
    });
    
    // No need to wait for sprite loading - initialize immediately
    initializeGame();

    // Force an immediate render to ensure maze displays
    setTimeout(() => {
      console.log('Forcing initial maze render...');
      console.log('Maze structure exists:', !!window.mazeStructure);
      console.log('Canvas exists:', !!window.canvas);
      console.log('Context exists:', !!window.ctx);
      console.log('CanvasRenderer exists:', !!window.CanvasRenderer);
      console.log('Maze size:', window.mazeSize);
      console.log('Cell size:', window.cellSize);
      console.log('Player position:', window.playerX, window.playerY);
      
      if (window.CanvasRenderer) {
        window.CanvasRenderer.renderFrame();
      }
    }, 100);

    // Auto-hide controls hint after 5 seconds
    setTimeout(() => {
      const controlsHint = document.getElementById('controls-hint');
      if (controlsHint && !controlsHint.classList.contains('hidden')) {
        controlsHint.classList.add('hidden');
      }
    }, 5000);

    // Add missing player position update function
    function updatePlayerPosition() {
      // PRIORITY: Update the visual sprite first (DOM-based sprite)
      if (window.CanvasRenderer && window.CanvasRenderer.updatePlayerPosition) {
        window.CanvasRenderer.updatePlayerPosition();
      }
      
      // Update virtual player for library compatibility (no visual offset)
      if (window.player && window.player.style) {
        window.player.style.left = window.playerX + "px";
        window.player.style.top = window.playerY + "px";
      }
      
      // Also call the PlayerController update if it exists
      if (window.PlayerController && window.PlayerController.updatePlayerPosition) {
        window.PlayerController.updatePlayerPosition();
      }
    }

    // Make this function globally available
    window.updatePlayerPosition = updatePlayerPosition;

  // Smooth pixel-based movement system - replaces cell-based movement
  window.addEventListener("keydown", (event) => {
    // Prevent movement if end screen is visible
    if (endScreen && !endScreen.classList.contains("hidden")) {
      return;
    }
    
    if (event.key === "y" || event.key === "Y") {
      // Calculate player's grid position for debugging
      const playerGridRow = Math.round(playerY / cellSize);
      const playerGridCol = Math.round(playerX / cellSize);
      const mazeCenter = Math.round(mazeSize / 2);
      const distanceFromCenter = Math.sqrt(Math.pow(playerGridRow - mazeCenter, 2) + Math.pow(playerGridCol - mazeCenter, 2));
      
      console.log(`Player Position: Row ${playerGridRow}, Col ${playerGridCol} (Pixel: ${playerX}, ${playerY}) (distance from center: ${distanceFromCenter.toFixed(2)})`);
      return;
    }
    
    // Handle dash key separately
    if (event.key === "Shift" || event.key === " ") {
      event.preventDefault();
      if (window.PlayerController) {
        window.PlayerController.handleDashKey();
      }
      return;
    }
    
    if (event.key.includes("Arrow") || event.key === "w" || event.key === "a" || event.key === "s" || event.key === "d") {
      event.preventDefault();
      
      // Start timer and music only once
      if (!interval) {
        interval = true;
        const timerResult = myLibrary.startTimer(timerElement);
        if (timerResult && timerResult.startTime) {
          startTime = timerResult.startTime;
          window.startTime = startTime;
        }
      }
      if (first === 0) {
        // Smart music playback - play immediately if loaded, queue if still loading
        if (audioPreloaded && !musicStarted) {
          // Audio ready - start music immediately
          setTimeout(() => {
            try {
              // Use AudioManager directly instead of myLibrary
              if (window.AudioManager) {
                window.AudioManager.playMusic();
                musicStarted = true;
                console.log('Music started successfully via AudioManager');
              } else {
                console.warn('AudioManager not available, trying myLibrary fallback');
                myLibrary.playMusic();
                musicStarted = true;
                console.log('Music started successfully via myLibrary');
              }
            } catch (error) {
              console.warn('Music playback failed:', error);
            }
          }, 0);
        } else if (!musicStarted && !window.audioCheckInterval) {
          // Audio not ready - set up a check to start music when available
          console.log('Audio still loading, will start music when ready...');
          window.audioCheckInterval = setInterval(() => {
            if (audioPreloaded && !musicStarted) {
              try {
                // Use AudioManager directly instead of myLibrary
                if (window.AudioManager) {
                  window.AudioManager.playMusic();
                  musicStarted = true;
                  console.log('Music started after audio loading completed via AudioManager');
                } else {
                  console.warn('AudioManager not available, trying myLibrary fallback');
                  myLibrary.playMusic();
                  musicStarted = true;
                  console.log('Music started after audio loading completed via myLibrary');
                }
                clearInterval(window.audioCheckInterval);
                window.audioCheckInterval = null;
              } catch (error) {
                console.warn('Music playback failed:', error);
                clearInterval(window.audioCheckInterval);
                window.audioCheckInterval = null;
              }
            }
          }, 250); // Check every 250ms instead of 100ms to reduce overhead
          
          // Safety timeout to prevent infinite checking (stop trying after 10 seconds)
          setTimeout(() => {
            if (!musicStarted && window.audioCheckInterval) {
              console.warn('Audio loading timeout - continuing without music');
              clearInterval(window.audioCheckInterval);
              window.audioCheckInterval = null;
            }
          }, 10000);
        }
        first++;
      }
      
      // Mark player as moving and handle smooth movement
      if (window.PlayerController) {
        // Hide controls hint when user starts moving
        const controlsHint = document.getElementById('controls-hint');
        if (controlsHint && !controlsHint.classList.contains('hidden')) {
          controlsHint.classList.add('hidden');
        }
        
        // Start smooth movement system if not already running
        if (window.PlayerController.startSmoothMovement && !window.PlayerController.isMovementActive) {
          window.PlayerController.startSmoothMovement();
        }
        window.PlayerController.handleKeyDown(event.key);
      }
    }
  });

  window.addEventListener("keyup", (event) => {
    if (event.key.includes("Arrow") || event.key === "w" || event.key === "a" || event.key === "s" || event.key === "d") {
      // Handle key release through PlayerController
      if (window.PlayerController) {
        window.PlayerController.handleKeyUp(event.key);
      }
    }
  });

  // Remove old cell-based movement function - replaced with smooth movement
  // function startContinuousMovement() { ... } - REMOVED
    
    // Event listeners setup moved to GameInitializer module
    if (window.GameInitializer) {
      window.GameInitializer.setupEventListeners();
    } else {
      console.warn('GameInitializer module not loaded for event listeners');
    }

    // =================================================================
    // GAME COORDINATION AND EVENT HANDLING
    // =================================================================
    // The following code coordinates the various modules and handles
    // browser events. Core game logic has been moved to modules.
    
    // Add cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (window.GameInitializer && window.GameInitializer.cleanupGameSystems) {
        window.GameInitializer.cleanupGameSystems();
      }
      if (window.PlayerController && window.PlayerController.cleanupMovementSystems) {
        window.PlayerController.cleanupMovementSystems();
      }
    });
    
    // Resize handling moved to GameInitializer module
  </script>
</body>
</html>
